//@version=6
indicator("Staggered Order Ladder Calculator", shorttitle="Staggered Ladder", overlay=true)

// Input parameters
budget = input.float(10000.0, title="Budget", minval=0.01, group="Ladder Settings")
current_price = input.float(50.0, title="Current Price", minval=0.01, group="Ladder Settings")
profit_target = input.float(50.0, title="Profit Target (%)", minval=10.0, maxval=200.0, group="Ladder Settings")
num_rungs = input.int(10, title="Number of Rungs", minval=1, maxval=20, group="Ladder Settings")
buy_price_range_pct = input.float(30.0, title="Buy Price Range (%)", minval=1.0, maxval=100.0, group="Ladder Settings")
show_tables = input.bool(true, title="Show Tables", group="Display")
show_price_levels = input.bool(true, title="Show Price Levels on Chart", group="Display")

// Initialize arrays
var buy_prices = array.new<float>()
var buy_quantities = array.new<float>()
var sell_prices = array.new<float>()
var sell_quantities = array.new<float>()
var cumulative_buy_cost = array.new<float>()
var cumulative_buy_qty = array.new<float>()
var cumulative_sell_revenue = array.new<float>()
var cumulative_sell_qty = array.new<float>()
var avg_buy_prices = array.new<float>()
var avg_sell_prices = array.new<float>()

// Initialize tables
var table summary_table = table.new(position.top_right, 2, 7, bgcolor=color.white, border_width=1)
var table buy_table = table.new(position.top_left, 6, 21, bgcolor=color.white, border_width=1)
var table sell_table = table.new(position.bottom_left, 6, 21, bgcolor=color.white, border_width=1)

// Validation
validate_inputs() =>
    errors = array.new<string>()
    if budget <= 0
        array.push(errors, "Budget must be positive")
    if current_price <= 0
        array.push(errors, "Current price must be positive")
    if profit_target < 10 or profit_target > 200
        array.push(errors, "Profit target must be between 10% and 200%")
    if num_rungs < 1 or num_rungs > 20
        array.push(errors, "Number of rungs must be between 1 and 20")
    if buy_price_range_pct <= 0 or buy_price_range_pct > 100
        array.push(errors, "Buy price range must be between 0% and 100%")
    errors

// Calculate exponential weights
// For buy: start_val=2.0, end_val=0.0 (higher weight for lower prices, index 0)
// For sell: start_val=0.0, end_val=2.0 (higher weight for higher prices, last index)
// Matches Python: np.exp(np.linspace(start, end, count))
calc_exponential_weights(count, start_val, end_val) =>
    weights = array.new<float>()
    if count == 1
        array.push(weights, 1.0)
    else
        for i = 0 to count - 1
            // Create linspace: from start_val to end_val over count points
            ratio = i / math.max(1, count - 1)
            linear_val = start_val + (end_val - start_val) * ratio
            exp_val = math.exp(linear_val)
            array.push(weights, exp_val)
    // Normalize weights to sum to 1.0
    sum_weights = 0.0
    for i = 0 to array.size(weights) - 1
        sum_weights += array.get(weights, i)
    if sum_weights > 0
        for i = 0 to array.size(weights) - 1
            array.set(weights, i, array.get(weights, i) / sum_weights)
    weights

// Calculate buy prices and quantities
calculate_buy_ladder() =>
    buy_upper = current_price
    price_range = buy_upper * (buy_price_range_pct / 100.0)
    buy_lower = buy_upper - price_range
    
    if buy_lower <= 0
        return false
    
    // Calculate buy prices (ascending: lowest to highest)
    array.clear(buy_prices)
    if num_rungs == 1
        array.push(buy_prices, buy_upper)
    else
        step = price_range / math.max(1, num_rungs - 1)
        for i = 0 to num_rungs - 1
            price = buy_lower + step * i
            array.push(buy_prices, price)
    
    // Calculate exponential weights for buy quantities
    buy_weights = calc_exponential_weights(num_rungs, 2.0, 0.0)
    
    // Calculate buy quantities
    array.clear(buy_quantities)
    for i = 0 to num_rungs - 1
        weight = array.get(buy_weights, i)
        price = array.get(buy_prices, i)
        qty = (budget * weight) / price
        array.push(buy_quantities, qty)
    
    // Normalize to exactly match budget
    total_cost = 0.0
    for i = 0 to num_rungs - 1
        total_cost += array.get(buy_quantities, i) * array.get(buy_prices, i)
    
    if total_cost > 0
        scale_factor = budget / total_cost
        for i = 0 to num_rungs - 1
            array.set(buy_quantities, i, array.get(buy_quantities, i) * scale_factor)
    
    true

// Calculate sell prices and quantities
calculate_sell_ladder() =>
    profit_multiplier = 1.0 + (profit_target / 100.0)
    
    // Calculate total buy quantity
    total_buy_qty = 0.0
    for i = 0 to num_rungs - 1
        total_buy_qty += array.get(buy_quantities, i)
    
    // Calculate total cost
    total_cost = 0.0
    for i = 0 to num_rungs - 1
        total_cost += array.get(buy_quantities, i) * array.get(buy_prices, i)
    
    // Calculate target revenue
    target_revenue = total_cost * profit_multiplier
    
    // Calculate exponential weights for sell quantities
    sell_weights = calc_exponential_weights(num_rungs, 0.0, 2.0)
    
    // Calculate sell quantities
    array.clear(sell_quantities)
    for i = 0 to num_rungs - 1
        weight = array.get(sell_weights, i)
        qty = total_buy_qty * weight
        array.push(sell_quantities, qty)
    
    // Ensure sell quantities match buy quantities exactly
    total_sell_qty = 0.0
    for i = 0 to num_rungs - 1
        total_sell_qty += array.get(sell_quantities, i)
    
    if total_sell_qty > 0 and math.abs(total_sell_qty - total_buy_qty) > 0.0001
        normalize_factor = total_buy_qty / total_sell_qty
        for i = 0 to num_rungs - 1
            array.set(sell_quantities, i, array.get(sell_quantities, i) * normalize_factor)
    
    // Calculate price step from buy prices
    max_buy_price = array.max(buy_prices)
    min_buy_price = array.min(buy_prices)
    price_step = num_rungs > 1 ? (max_buy_price - min_buy_price) / (num_rungs - 1) : max_buy_price * 0.1
    
    // Calculate gap and minimum sell price
    base_gap_pct = profit_target / 100.0
    base_gap_size = max_buy_price * base_gap_pct * 0.5
    gap_steps = math.max(1, math.ceil(base_gap_size / price_step))
    gap_size = gap_steps * price_step
    min_sell_price = max_buy_price + gap_size
    
    // Create sell prices with consistent spacing
    array.clear(sell_prices)
    for i = 0 to num_rungs - 1
        price = min_sell_price + i * price_step
        array.push(sell_prices, price)
    
    // Calculate current revenue
    current_revenue = 0.0
    for i = 0 to num_rungs - 1
        current_revenue += array.get(sell_prices, i) * array.get(sell_quantities, i)
    
    // Adjust sell prices to achieve target revenue
    if current_revenue > 0 and math.abs(current_revenue - target_revenue) > 0.01
        price_scale = target_revenue / current_revenue
        for i = 0 to num_rungs - 1
            array.set(sell_prices, i, array.get(sell_prices, i) * price_scale)
        
        // Ensure gap is maintained after scaling
        max_buy_price_after = array.max(buy_prices)
        min_sell_price_after = array.min(sell_prices)
        required_gap = price_step
        min_valid_sell_price = max_buy_price_after + required_gap
        
        if min_sell_price_after < min_valid_sell_price
            price_shift = min_valid_sell_price - min_sell_price_after
            for i = 0 to num_rungs - 1
                array.set(sell_prices, i, array.get(sell_prices, i) + price_shift)
    
    // Final quantity matching check
    final_total_sell_qty = 0.0
    for i = 0 to num_rungs - 1
        final_total_sell_qty += array.get(sell_quantities, i)
    
    if math.abs(final_total_sell_qty - total_buy_qty) > 0.0001
        if final_total_sell_qty > 0
            normalize_factor = total_buy_qty / final_total_sell_qty
            for i = 0 to num_rungs - 1
                array.set(sell_quantities, i, array.get(sell_quantities, i) * normalize_factor)
    
    true

// Calculate cumulative statistics
calculate_statistics() =>
    // Clear arrays
    array.clear(cumulative_buy_cost)
    array.clear(cumulative_buy_qty)
    array.clear(cumulative_sell_revenue)
    array.clear(cumulative_sell_qty)
    array.clear(avg_buy_prices)
    array.clear(avg_sell_prices)
    
    // Calculate average buy prices (from index i to end)
    for i = 0 to num_rungs - 1
        // Include all buy orders from index i to the end
        // If price drops to buy_prices[i], orders from buy_prices[i] to buy_prices[-1] have executed
        total_cost_from_level = 0.0
        total_qty_from_level = 0.0
        
        for j = i to num_rungs - 1
            total_cost_from_level += array.get(buy_quantities, j) * array.get(buy_prices, j)
            total_qty_from_level += array.get(buy_quantities, j)
        
        avg_buy_price = total_qty_from_level > 0 ? total_cost_from_level / total_qty_from_level : 0.0
        array.push(avg_buy_prices, avg_buy_price)
    
    // Verify highest buy average equals highest buy price
    if array.size(avg_buy_prices) > 0
        highest_index = num_rungs - 1
        expected_avg = array.get(buy_prices, highest_index)
        actual_avg = array.get(avg_buy_prices, highest_index)
        if math.abs(actual_avg - expected_avg) > 0.0001
            array.set(avg_buy_prices, highest_index, expected_avg)
    
    // Calculate average sell prices (from index 0 to i)
    for i = 0 to num_rungs - 1
        // Include all sell orders from index 0 to i
        // If price rises to sell_prices[i], orders from sell_prices[0] to sell_prices[i] execute
        total_revenue_to_level = 0.0
        total_qty_to_level = 0.0
        
        for j = 0 to i
            total_revenue_to_level += array.get(sell_quantities, j) * array.get(sell_prices, j)
            total_qty_to_level += array.get(sell_quantities, j)
        
        avg_sell_price = total_qty_to_level > 0 ? total_revenue_to_level / total_qty_to_level : 0.0
        array.push(avg_sell_prices, avg_sell_price)
    
    // Verify first sell average equals first sell price
    if array.size(avg_sell_prices) > 0
        expected_first_avg = array.get(sell_prices, 0)
        actual_first_avg = array.get(avg_sell_prices, 0)
        if math.abs(actual_first_avg - expected_first_avg) > 0.0001
            array.set(avg_sell_prices, 0, expected_first_avg)
    
    // Calculate cumulative values (for display)
    running_buy_cost = 0.0
    running_buy_qty = 0.0
    running_sell_revenue = 0.0
    running_sell_qty = 0.0
    
    for i = 0 to num_rungs - 1
        running_buy_cost += array.get(buy_quantities, i) * array.get(buy_prices, i)
        running_buy_qty += array.get(buy_quantities, i)
        array.push(cumulative_buy_cost, running_buy_cost)
        array.push(cumulative_buy_qty, running_buy_qty)
        
        running_sell_revenue += array.get(sell_quantities, i) * array.get(sell_prices, i)
        running_sell_qty += array.get(sell_quantities, i)
        array.push(cumulative_sell_revenue, running_sell_revenue)
        array.push(cumulative_sell_qty, running_sell_qty)
    
    // Final quantity matching verification
    total_buy_qty = 0.0
    total_sell_qty = 0.0
    for i = 0 to num_rungs - 1
        total_buy_qty += array.get(buy_quantities, i)
        total_sell_qty += array.get(sell_quantities, i)
    
    qty_diff = math.abs(total_buy_qty - total_sell_qty)
    if qty_diff > 0.0001 and total_sell_qty > 0
        normalize_factor = total_buy_qty / total_sell_qty
        for i = 0 to num_rungs - 1
            array.set(sell_quantities, i, array.get(sell_quantities, i) * normalize_factor)
        
        // Recalculate sell statistics after correction
        array.clear(avg_sell_prices)
        array.clear(cumulative_sell_revenue)
        array.clear(cumulative_sell_qty)
        
        for i = 0 to num_rungs - 1
            total_revenue_to_level = 0.0
            total_qty_to_level = 0.0
            for j = 0 to i
                total_revenue_to_level += array.get(sell_quantities, j) * array.get(sell_prices, j)
                total_qty_to_level += array.get(sell_quantities, j)
            avg_sell_price = total_qty_to_level > 0 ? total_revenue_to_level / total_qty_to_level : 0.0
            array.push(avg_sell_prices, avg_sell_price)
        
        running_sell_revenue = 0.0
        running_sell_qty = 0.0
        for i = 0 to num_rungs - 1
            running_sell_revenue += array.get(sell_quantities, i) * array.get(sell_prices, i)
            running_sell_qty += array.get(sell_quantities, i)
            array.push(cumulative_sell_revenue, running_sell_revenue)
            array.push(cumulative_sell_qty, running_sell_qty)
        
        // Verify first sell average again
        if array.size(avg_sell_prices) > 0
            expected_first_avg = array.get(sell_prices, 0)
            actual_first_avg = array.get(avg_sell_prices, 0)
            if math.abs(actual_first_avg - expected_first_avg) > 0.0001
                array.set(avg_sell_prices, 0, expected_first_avg)

// Main calculation
errors = validate_inputs()
if array.size(errors) == 0
    if calculate_buy_ladder()
        if calculate_sell_ladder()
            calculate_statistics()
else
    // Show errors in table
    if show_tables
        table.cell_set_text(summary_table, 0, 0, "ERROR", text_color=color.red, bgcolor=color.yellow)
        error_msg = array.get(errors, 0)
        table.cell_set_text(summary_table, 0, 1, error_msg, text_color=color.red)

// Calculate totals for display
total_cost = array.size(cumulative_buy_cost) > 0 ? array.get(cumulative_buy_cost, num_rungs - 1) : 0.0
total_revenue = array.size(cumulative_sell_revenue) > 0 ? array.get(cumulative_sell_revenue, num_rungs - 1) : 0.0
total_profit = total_revenue - total_cost
profit_pct = total_cost > 0 ? (total_profit / total_cost * 100.0) : 0.0

// Update summary table
if show_tables and array.size(errors) == 0
    table.cell_set_text(summary_table, 0, 0, "Summary", text_color=color.white, bgcolor=color.new(#366092, 0), text_size=size.normal)
    table.cell_set_text(summary_table, 0, 1, "", bgcolor=color.new(#366092, 0))
    
    table.cell_set_text(summary_table, 1, 0, "Budget", text_color=color.black, bgcolor=color.white)
    table.cell_set_text(summary_table, 1, 1, str.tostring(budget, "#,##0.00"), text_color=color.black, bgcolor=color.white)
    
    table.cell_set_text(summary_table, 2, 0, "Rungs", text_color=color.black, bgcolor=color.white)
    table.cell_set_text(summary_table, 2, 1, str.tostring(num_rungs), text_color=color.black, bgcolor=color.white)
    
    table.cell_set_text(summary_table, 3, 0, "Total Cost", text_color=color.black, bgcolor=color.white)
    table.cell_set_text(summary_table, 3, 1, str.tostring(total_cost, "#,##0.00"), text_color=color.black, bgcolor=color.white)
    
    table.cell_set_text(summary_table, 4, 0, "Total Revenue", text_color=color.black, bgcolor=color.white)
    table.cell_set_text(summary_table, 4, 1, str.tostring(total_revenue, "#,##0.00"), text_color=color.black, bgcolor=color.white)
    
    table.cell_set_text(summary_table, 5, 0, "Total Profit", text_color=color.black, bgcolor=color.white)
    table.cell_set_text(summary_table, 5, 1, str.tostring(total_profit, "#,##0.00"), text_color=color.black, bgcolor=color.white)
    
    table.cell_set_text(summary_table, 6, 0, "Profit %", text_color=color.black, bgcolor=color.white)
    table.cell_set_text(summary_table, 6, 1, str.tostring(profit_pct, "#,##0.00") + "%", text_color=color.black, bgcolor=color.white)

// Update buy orders table
if show_tables and array.size(errors) == 0
    // Header
    table.cell_set_text(buy_table, 0, 0, "Buy Orders", text_color=color.white, bgcolor=color.new(#366092, 0), text_size=size.normal)
    table.cell_set_text(buy_table, 1, 0, "Price", text_color=color.white, bgcolor=color.new(#366092, 0))
    table.cell_set_text(buy_table, 2, 0, "Qty", text_color=color.white, bgcolor=color.new(#366092, 0))
    table.cell_set_text(buy_table, 3, 0, "Cost", text_color=color.white, bgcolor=color.new(#366092, 0))
    table.cell_set_text(buy_table, 4, 0, "Cum Cost", text_color=color.white, bgcolor=color.new(#366092, 0))
    table.cell_set_text(buy_table, 5, 0, "Avg Price", text_color=color.white, bgcolor=color.new(#366092, 0))
    
    // Data (reversed: order 1 = highest price, order 10 = lowest price)
    for i = 0 to math.min(num_rungs - 1, 19)
        row_idx = num_rungs - 1 - i
        if row_idx >= 0 and row_idx < num_rungs
            price = array.get(buy_prices, row_idx)
            qty = array.get(buy_quantities, row_idx)
            cost = price * qty
            cum_cost = array.get(cumulative_buy_cost, row_idx)
            avg_price = array.get(avg_buy_prices, row_idx)
            
            table.cell_set_text(buy_table, 0, i + 1, "Order " + str.tostring(i + 1), text_color=color.black, bgcolor=color.white)
            table.cell_set_text(buy_table, 1, i + 1, str.tostring(price, "#,##0.00"), text_color=color.black, bgcolor=color.white)
            table.cell_set_text(buy_table, 2, i + 1, str.tostring(qty, "#,##0.0000"), text_color=color.black, bgcolor=color.white)
            table.cell_set_text(buy_table, 3, i + 1, str.tostring(cost, "#,##0.00"), text_color=color.black, bgcolor=color.white)
            table.cell_set_text(buy_table, 4, i + 1, str.tostring(cum_cost, "#,##0.00"), text_color=color.black, bgcolor=color.white)
            table.cell_set_text(buy_table, 5, i + 1, str.tostring(avg_price, "#,##0.00"), text_color=color.black, bgcolor=color.white)

// Update sell orders table
if show_tables and array.size(errors) == 0
    // Header
    table.cell_set_text(sell_table, 0, 0, "Sell Orders", text_color=color.white, bgcolor=color.new(#366092, 0), text_size=size.normal)
    table.cell_set_text(sell_table, 1, 0, "Price", text_color=color.white, bgcolor=color.new(#366092, 0))
    table.cell_set_text(sell_table, 2, 0, "Qty", text_color=color.white, bgcolor=color.new(#366092, 0))
    table.cell_set_text(sell_table, 3, 0, "Revenue", text_color=color.white, bgcolor=color.new(#366092, 0))
    table.cell_set_text(sell_table, 4, 0, "Cum Rev", text_color=color.white, bgcolor=color.new(#366092, 0))
    table.cell_set_text(sell_table, 5, 0, "Avg Price", text_color=color.white, bgcolor=color.new(#366092, 0))
    
    // Data (ascending: order 1 = lowest price, order 10 = highest price)
    for i = 0 to math.min(num_rungs - 1, 19)
        price = array.get(sell_prices, i)
        qty = array.get(sell_quantities, i)
        revenue = price * qty
        cum_revenue = array.get(cumulative_sell_revenue, i)
        avg_price = array.get(avg_sell_prices, i)
        
        table.cell_set_text(sell_table, 0, i + 1, "Order " + str.tostring(i + 1), text_color=color.black, bgcolor=color.white)
        table.cell_set_text(sell_table, 1, i + 1, str.tostring(price, "#,##0.00"), text_color=color.black, bgcolor=color.white)
        table.cell_set_text(sell_table, 2, i + 1, str.tostring(qty, "#,##0.0000"), text_color=color.black, bgcolor=color.white)
        table.cell_set_text(sell_table, 3, i + 1, str.tostring(revenue, "#,##0.00"), text_color=color.black, bgcolor=color.white)
        table.cell_set_text(sell_table, 4, i + 1, str.tostring(cum_revenue, "#,##0.00"), text_color=color.black, bgcolor=color.white)
        table.cell_set_text(sell_table, 5, i + 1, str.tostring(avg_price, "#,##0.00"), text_color=color.black, bgcolor=color.white)

// Display price levels on chart using labels (hline can't be used in loops)
if show_price_levels and array.size(errors) == 0 and barstate.islast
    // Buy price levels - show key levels only (lowest, middle, highest)
    if array.size(buy_prices) > 0
        // Lowest buy price
        lowest_buy = array.get(buy_prices, 0)
        label.new(bar_index, lowest_buy, "Buy Low: " + str.tostring(lowest_buy, "#,##0.00"), 
                  color=color.new(color.green, 0), textcolor=color.white, style=label.style_label_down, size=size.small)
        
        // Highest buy price
        highest_buy = array.get(buy_prices, num_rungs - 1)
        label.new(bar_index, highest_buy, "Buy High: " + str.tostring(highest_buy, "#,##0.00"), 
                  color=color.new(color.green, 0), textcolor=color.white, style=label.style_label_down, size=size.small)
        
        // Middle buy price (if more than 2 rungs)
        if num_rungs > 2
            mid_idx = math.floor(num_rungs / 2)
            mid_buy = array.get(buy_prices, mid_idx)
            label.new(bar_index, mid_buy, "Buy Mid: " + str.tostring(mid_buy, "#,##0.00"), 
                      color=color.new(color.green, 20), textcolor=color.white, style=label.style_label_down, size=size.tiny)
    
    // Sell price levels - show key levels only (lowest, middle, highest)
    if array.size(sell_prices) > 0
        // Lowest sell price
        lowest_sell = array.get(sell_prices, 0)
        label.new(bar_index, lowest_sell, "Sell Low: " + str.tostring(lowest_sell, "#,##0.00"), 
                  color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_up, size=size.small)
        
        // Highest sell price
        highest_sell = array.get(sell_prices, num_rungs - 1)
        label.new(bar_index, highest_sell, "Sell High: " + str.tostring(highest_sell, "#,##0.00"), 
                  color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_up, size=size.small)
        
        // Middle sell price (if more than 2 rungs)
        if num_rungs > 2
            mid_idx = math.floor(num_rungs / 2)
            mid_sell = array.get(sell_prices, mid_idx)
            label.new(bar_index, mid_sell, "Sell Mid: " + str.tostring(mid_sell, "#,##0.00"), 
                      color=color.new(color.red, 20), textcolor=color.white, style=label.style_label_up, size=size.tiny)

